[id='con-traits_{context}']

= Traits in the {DECISION_ENGINE}
Traits in the {DECISION_ENGINE} allow you to model multiple dynamic types that do not fit in a class hierarchy. A trait is an interface that you can apply (and eventually remove) to an individual object at runtime. However, traits are not supported in the executable rule model, therefore traits and its specific implementation code are moved to an individual module named `drools-traits`. To use traits, you can import the `drools-traits` module to Maven.

The `drools-traits` module is based on the `drools-core` and `drools-compiler` module. The classes from `drools-core` and `drools-compiler` are moved to the `drools-traits` module, containing `.traits` prefix in package name and `-Impl` suffix in class name to avoid the split problem.

NOTE: A class or an interface that is used specifically by traits is moved to the `drools-traits` module.

== Components in traits

Traits require the following components:

[source]
----
org.drools.core.reteoo.KieComponentFactoryFactory=org.drools.traits.core.reteoo.TraitKieComponentFactoryFactory
org.drools.compiler.builder.impl.TypeDeclarationBuilderFactory=org.drools.traits.compiler.builder.impl.TraitTypeDeclarationBuilderFactory
----

To use traits, you must instantiate the specific traits classes using the service loader mechanism. For example, the `kie.conf` file in the `drools-traits` module supports the execution of traits related tests that are available in the `drools-core` and `drools-compiler` module:

.Example `kie.conf`

[source]
----
org.drools.core.reteoo.KieComponentFactoryFactory=org.drools.traits.core.reteoo.TraitKieComponentFactoryFactory
org.drools.compiler.builder.impl.TypeDeclarationBuilderFactory=org.drools.traits.compiler.builder.impl.TraitTypeDeclarationBuilderFactory
org.kie.api.persistence.jpa.KieStoreServices = org.drools.persistence.jpa.KnowledgeStoreServiceImpl
?org.kie.internal.process.CorrelationKeyFactory = org.jbpm.persistence.correlation.JPACorrelationKeyFactory
----

IMPORTANT: Persistence related tests are moved to the `drools-traits` module. Therefore, the `kie.conf` file contains `KieStoreServices` defined for persistence.

The `drools-core` module delegates the instance creation to the factory classes, for example, the constructor of `org.drools.core.reteoo.AlphaNode` cannot be called directly, instead use `org.drools.core.reteoo.builder.PhreakNodeFactory`. Also, `AlphaNode.java` contains traits specific code, which you can remove. For example, you can remove the code in `calculateDeclaredMask`.

When you implement `org.drools.core.reteoo.builder.PhreakNodeFactory => org.drools.traits.core.reteoo.TraitPhreakNodeFactory` differently, then you can create the instances of `org.drools.traits.core.reteoo.TraitAlphaNode` and move the specific traits code to the `drools-traits` module.

[source,java]
----
package org.drools.traits.core.reteoo;
import java.util.List;

import org.drools.traits.core.base.evaluators.IsAEvaluatorDefinition;
import org.drools.core.reteoo.AlphaNode;
import org.drools.core.reteoo.ObjectSource;
import org.drools.core.reteoo.PropertySpecificUtil;
import org.drools.core.reteoo.builder.BuildContext;
import org.drools.core.rule.constraint.EvaluatorConstraint;
import org.drools.core.spi.AlphaNodeFieldConstraint;
import org.drools.core.util.bitmask.BitMask;
import org.kie.api.runtime.rule.Operator;

public class TraitAlphaNode extends AlphaNode {

    public TraitAlphaNode() {
    }

    public TraitAlphaNode(int id, AlphaNodeFieldConstraint constraint, ObjectSource objectSource, BuildContext context) {
        super(id, constraint, objectSource, context);
    }

    @Override
    public BitMask calculateDeclaredMask(Class modifiedClass, List<String> settableProperties) {
        BitMask mask = constraint.getListenedPropertyMask(modifiedClass, settableProperties);
        if (isTraitEvaluator()) {
            return mask.set(PropertySpecificUtil.TRAITABLE_BIT);
        }
        return mask;
    }

    private boolean isTraitEvaluator() {
        if (constraint instanceof EvaluatorConstraint && ((EvaluatorConstraint) constraint).isSelf()) {
            Operator op = ((EvaluatorConstraint) constraint).getEvaluator().getOperator();
            return op == IsAEvaluatorDefinition.ISA || op == IsAEvaluatorDefinition.NOT_ISA;
        }
        return false;
    }
}
----

`org.drools.core.reteoo.KieComponentFactory` object creates the factories, and it is instantiated directly in `org.drools.core.RuleBaseConfiguration`. You can add the `org.drools.core.reteoo.KieComponentFactory` object in the `kie.conf` file if it is not stateful. However, a new instance needs to be created once in the `init` method in `org.drools.core.RuleBaseConfiguration`.

When you add `KieComponentFactory` in the service loader, then a single `KieComponentFactory` is created for each class loader.

To add a different `org.drools.core.reteoo.KieComponentFactory`, create a `org.drools.core.reteoo.KieComponentFactoryFactory` that you can add in the `kie.conf` file, for example:

[source]
----
org.drools.core.reteoo.KieComponentFactoryFactory=org.drools.traits.core.reteoo.TraitKieComponentFactoryFactory
----

In case the `org.drools.traits.core.reteoo.TraitKieComponentFactoryFactory` object is missing, then by default `org.drools.core.reteoo.KieComponentFactory` object is created. `TraitKieComponentFactoryFactory` creates the `TraitKieComponentFactory` component, which stores the required traits related code.

Other subclass objects examples:

* `org.drools.core.common.NamedEntryPoint => org.drools.traits.core.common.TraitNamedEntryPoint`

* `org.drools.core.common.DefaultFactHandle => org.drools.traits.core.common.TraitDefaultFactHandle`
